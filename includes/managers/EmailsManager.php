<?php

/**
 * @file EmailsManager.php
 * @author Alejandro Dario Simi
 */

namespace TooBasic\Managers;

//
// Class aliases.
use \TooBasic\Email;
use \TooBasic\EmailPayload;
use \TooBasic\Exception;
use \TooBasic\Names;
use \TooBasic\Paths;

/**
 * @class EmailsManager
 * This manager is the one in charge of interpreting an email generation.
 */
class EmailsManager extends Manager {
	//
	// Protected properties.
	/**
	 * @var \TooBasic\EmailPayload Data set to be use while rendering an
	 * sending a mail.
	 */
	protected $_emailPayload = false;
	/**
	 * @var string This is a shortcut to the last rendering result generated
	 * by method 'run()'.
	 */
	protected $_lastRender = false;
	//
	// Public methods.
	/**
	 * This method provides access to the last redering result generated by
	 * method 'run()'.
	 *
	 * @return string Retunrs a rendering result.
	 */
	public function lastRender() {
		return $this->_lastRender;
	}
	/**
	 * This is the main method to call in order to execute a email.
	 *
	 * @param boolean $autoDisplay This flag tells to actually prompt the
	 * generated output. It works only if it's a simulation.
	 * @return mixed[string] Returns the execution's result.
	 */
	public function run($autoDisplay = false) {
		//
		// Checking simulation status.
		$isSimulation = isset($this->params->get->debugemail);
		//
		// Payload checks.
		if($isSimulation) {
			//
			// On a simulation, a dummy payload is used.
			$this->_emailPayload = new EmailPayload();
			$this->_emailPayload->setName($this->params->get->debugemail);
		} elseif($this->_emailPayload === false) {
			//
			// If it's not a simulation, there should be a payload
			// set.
			throw new Exception("No email payload set, use 'EmailsManager::Instance()->setEmailPayload()'");
		} elseif(!$this->_emailPayload->isValid()) {
			//
			// If it's not a simulation, there should be a valid
			// payload set.
			throw new Exception("Email payload is not valid, check email name, recipients and subject");
		}
		//
		// Default values.
		$layoutName = false;
		//
		// Current email execution.
		$emailLastRun = self::ExecuteAction($this->_emailPayload->name(), $this->_emailPayload, $isSimulation, null, $layoutName);
		//
		// Layout execution (if any).
		$layoutLastRun = false;
		//
		// Running layout's controller.
		if($layoutName) {
			$this->_emailPayload->setLayout($layoutName);
			$layoutLastRun = self::ExecuteAction($layoutName, $this->_emailPayload, $isSimulation, $emailLastRun);
		}
		//
		// If there's a layout present, controller's result must
		// be shown inside a layout's result.
		if($layoutLastRun) {
			$emailLastRun[GC_AFIELD_FULL_RENDER] = str_replace('%TOO_BASIC_EMAIL_CONTENT%', $emailLastRun[GC_AFIELD_RENDER], $layoutLastRun[GC_AFIELD_RENDER]);
		} else {
			$emailLastRun[GC_AFIELD_FULL_RENDER] = $emailLastRun[GC_AFIELD_RENDER];
		}
		//
		// Stripping tags that may be a problem for some email clients.
		if($this->_emailPayload->stripTags()) {
			self::StripContentTags($emailLastRun[GC_AFIELD_FULL_RENDER]);
		}
		//
		// Autodisplay works only on simulations.
		if($autoDisplay && $isSimulation) {
			echo $emailLastRun[GC_AFIELD_FULL_RENDER];
		}
		//
		// Setting the last rendering result.
		$this->_lastRender = $emailLastRun[GC_AFIELD_FULL_RENDER];

		return $emailLastRun;
	}
	/**
	 * This method holds the logic to send an email based on the las render
	 * and information given as payload.
	 *
	 * @return boolean Returns TRUE when the email was send. This doesn't mean
	 * it was delivered.
	 * @throws \TooBasic\Exception
	 */
	public function send() {
		$ok = true;
		//
		//
		if($this->_emailPayload->isValid() && $this->lastRender()) {
			//
			// Global dependencies.
			global $Defaults;
			//
			// Email headers.
			$headers = 'From: '.strip_tags($Defaults[GC_DEFAULTS_EMAIL_FROM])."\r\n";
			$headers .= 'Reply-To: '.strip_tags($Defaults[GC_DEFAULTS_EMAIL_REPLAYTO])."\r\n";
			$headers .= "MIME-Version: 1.0\r\n";
			$headers .= "Content-Type: text/html; charset=utf-8\r\n";
			$headers .= 'X-PowerdBy: TooBasic '.TOOBASIC_VERSION."\r\n";
			//
			// Sending mail.
			$ok = mail($this->_emailPayload->emails(), $this->_emailPayload->subject(), $this->lastRender(), $headers);
		} elseif(!$this->lastRender()) {
			throw new Exception('Email was not rendered yet');
		} else {
			throw new Exception('Email payload structure is not valid');
		}

		return $ok;
	}
	/**
	 * This method sets teh email payload to use on rendering and sending.
	 *
	 * @param \TooBasic\EmailPayload $payload Payload object to be set.
	 */
	public function setEmailPayload(EmailPayload $payload) {
		$this->_emailPayload = $payload;
	}
	//
	// Public class methods.
	/**
	 * This class method loads a specific email controller, execute it and
	 * retruns it's result.
	 *
	 * @param string $emailName Name of the email controller to execute.
	 * @param \TooBasic\EmailPayload $emailPayload Data set to use while
	 * rendering.
	 * @param boolean $isSimulation This flag indicates if it's simulation or
	 * not.
	 * @param mixed[string] $previousActionRun Execution results from a
	 * previous controller, useful for layouts.
	 * @param string $layoutName Returns the name of the layout used by the
	 * controller.
	 * @return mixed[string] Returns an execution result structure.
	 * @throws \TooBasic\Exception
	 */
	public static function ExecuteAction($emailName, $emailPayload, $isSimulation, $previousActionRun = null, &$layoutName = false) {
		//
		// Default values.
		$status = true;
		$lastRun = false;
		//
		// Loading controller based on current email name.
		$controllerClass = self::FetchController($emailName, $emailPayload);
		//
		// Checking if the load was a success.
		if($controllerClass !== false) {
			//
			// Obtaining a name for the layout used by the controller.
			$layoutName = $controllerClass->layout();
			//
			// If there's a previous run, this must be the layout and
			// the previous run comes from the controller, so
			// assignments from that controller should be available
			// for the layout for different reason like setting the
			// page title.
			if(is_array($previousActionRun)) {
				/** @fixme There should be a way to change layout's cache key setting from the controller. */
				$controllerClass->massiveAssign($previousActionRun['assignments']);
			}
			//
			// Executing the controller.
			$controllerClass->setSimulation($isSimulation);
			$status = $controllerClass->run();
		} else {
			$status = false;
		}
		//
		// Checking execution status.
		if($status) {
			//
			// At this point, the controller was executed
			// successfully.
			$lastRun = $controllerClass->lastRun();
		} else {
			//
			// At this point there was an error executing the
			// controller.
			//
			// Who found it?
			$whatIsIt = (is_array($previousActionRun) ? 'email layout' : 'email');
			//
			// Setting error a message and code to show.
			$errorCode = HTTPERROR_NOT_FOUND;
			$errorMessage = "Unable to find {$whatIsIt} '{$emailName}'";
			//
			// Checking if the controller's class was at least loaded.
			if($controllerClass instanceof Email) {
				//
				// Obtainig the last error found by the
				// controller.
				$lastError = $controllerClass->lastError();
				//
				// If the controller found an error, it's used as
				// code and message.
				if($lastError) {
					$errorCode = $lastError[GC_AFIELD_CODE];
					$errorMessage = $lastError[GC_AFIELD_MESSAGE];
				} else {
					$errorCode = HTTPERROR_INTERNAL_SERVER_ERROR;
					$errorMessage = "Something went wrong with email '{$emailName}'";
				}
			}
			//
			// Triggering an exception with the message generated.
			throw new Exception($errorMessage, $errorCode);
		}

		return $lastRun;
	}
	/**
	 * This class method looks for a controller based on an email name.
	 *
	 * @param string $emailName Action name from which guess a controller's
	 * name.
	 * @return \TooBasic\Controller Returns a controllers object or false on
	 * failure.
	 */
	public static function FetchController($emailName, $emailPayload, $recursive = false) {
		//
		// Default values.
		$out = false;
		//
		// Looking for a controller with the given email name as a file
		// name.
		$controllerPath = Paths::Instance()->emailControllerPath($emailName);
		//
		// Checking the obtained path.
		if($controllerPath) {
			//
			// Loading physical file with the controllers definition.
			require_once $controllerPath;
			//
			// Guessing the right class name.
			$controllerClassName = Names::EmailControllerClass($emailName);
			//
			// Creating the controllers class.
			if(class_exists($controllerClassName)) {
				$out = new $controllerClassName($emailPayload);
			} else {
				throw new Exception("Class '{$controllerClassName}' is not defined. File '{$controllerPath}' doesn't seem to load the right object.");
			}
		} elseif(!$recursive) {
			//
			// If there's no controller file, but there's a template,
			// a virtual controller is used.
			//
			// Searching for a template.
			$template = Paths::Instance()->templatePath($emailName, 'email');
			//
			// Checking if there's a template for the given name.
			if($template) {
				//
				// Loading a virtual controller.
				$out = self::FetchController('too_basic_virtual', $emailPayload, true);
				//
				// Setting view name to the virtual controller.
				if($out) {
					$out->setViewName($emailName);
				}
			}
		}
		//
		// Returning fetched controller.
		return $out;
	}
	/**
	 * This class method provides a logic to remove these HTML tags:
	 * 	- script
	 * 	- style
	 * This is usually removed by some email clients and it's better to work
	 * thinking they may not be present when a user reads an email.
	 *
	 * @param string $content Text to clean up.
	 */
	public static function StripContentTags(&$content) {
		$content = preg_replace('%<style( |>)(.*)</style>%s', '<!--CSS removed by TooBasic-->', $content);
		$content = preg_replace('%<script( |>)(.*)</script>%s', '<!--JS removed by TooBasic-->', $content);
	}
}
